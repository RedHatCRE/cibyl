"""
#    Copyright 2022 Red Hat
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
"""
import logging
from abc import ABC, abstractmethod
from typing import Iterable

from overrides import overrides

from cibyl.models.ci.zuul.job import Job
from cibyl.utils.tree import Leaf, Tree

LOG = logging.getLogger(__name__)


class TreeFactory(ABC):
    """Interface for all classes that generate tree structures out of Zuul
    models.
    """

    @abstractmethod
    def from_jobs(self, jobs: Iterable[Job]) -> Tree[Job]:
        """Builds a tree structure that provides a distribution between the
        models provided. This distribution is up for the implementation to
        decide.

        :param jobs: Jobs to generate the tree for.
        :return: Tree structure on which each node represents one of the
            given nodes. Aside from the root node, all other nodes will contain
            in its value the model that it used as reference.
        """
        raise NotImplementedError


class FlatTreeFactory(TreeFactory):
    """Implements :class:`TreeFactory` by ignoring any relationship between
    models and just listing all of them below the root node.
    """

    ROOT_NAME: str = '.'
    """Identifier for the root node of the trees generated by this factory."""

    @overrides
    def from_jobs(self, jobs: Iterable[Job]) -> Tree[Job]:
        return Tree(
            root=Leaf[Job](
                name=self.ROOT_NAME,
                children=[self._new_detached_leaf(job) for job in jobs],
                value=None
            )
        )

    def _new_detached_leaf(self, job: Job) -> Leaf[Job]:
        """Creates an element within the tree that represents the given job.
        This element is left unlinked, meaning that it has not parent or
        children.

        :param job: The job to create the node for.
        :return: The node.
        """
        return Leaf(name=job.name.value, value=job)


class HierarchicalTreeFactory(FlatTreeFactory):
    """Implementation of :class:`TreeFactory` that generates trees following
    the parent-child relationship between the models.
    """

    @overrides
    def from_jobs(self, jobs: Iterable[Job]) -> Tree[Job]:
        # First iteration -> List all jobs without a hierarchy.
        # This will avoid conflicts when a child is added before its parent.
        tree = super().from_jobs(jobs)

        # Second iteration -> Generate the hierarchy.
        for job in jobs:
            # Look for the leaves of the job, just one at the start.
            leaves = list(tree.find_by_name(job.name.value))

            for variant in job.variants.value:
                # Look for the leaf to fall under
                parent = self._find_parent(tree, variant)

                if leaves:
                    # If we already have leaves for the job, use those
                    leaf = leaves.pop()
                    leaf.parent = parent
                else:
                    # Otherwise, add a new one
                    parent.children = [
                        self._new_detached_leaf(job),
                        *parent.children
                    ]

        return tree

    def _find_parent(self, tree: Tree[Job], variant: Job.Variant) -> Leaf[Job]:
        """Looks for the node that represents the parent job of the given
        variant.

        There are certain conditions to this search:
            - If the variant has no parent -> Root is returned.
            - If there is no parent node -> Root is returned.
            - If there are more than one parent node -> Root is returned.

        :param tree: The tree to look for nodes in.
        :param variant: The variant to look for the parent of.
        :return: Node of the parent job.
        """
        if not variant.parent:
            LOG.debug(
                "Found root job at: '%(job)s'.",
                {'job': variant.name.value}
            )
            return tree.root

        parents = list(tree.find_by_name(variant.parent.value))

        if not parents:
            LOG.warning(
                "Parent for job: '%(job)s' not found on query results. "
                "Leaving job at root level...",
                {'job': variant.name.value}
            )
            return tree.root

        if len(parents) > 1:
            # TODO: Figure out what to link to on these cases
            LOG.warning(
                "More than one parent for job: '%(job)s' found on query "
                "results. Leaving job at root level...",
                {'job': variant.name.value}
            )
            return tree.root

        return parents[0]
